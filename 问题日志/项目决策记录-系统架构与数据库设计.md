# 项目决策记录 - 系统架构与数据库设计

## 概述
本文档整合了Solo Lottery项目中所有与系统架构、数据库设计、数据管理相关的项目决策记录，涵盖了从数据库重构到数据初始化策略的完整技术演进过程。

---

## 一、数据库结构设计与重构

### 1.1 数据库结构重新设计
**来源**：项目决策记录01
**设计背景**：原有数据库结构过于简单，无法满足复杂抽奖系统需求

**新数据库表结构**：
1. **管理员表 (Admins)**：存储系统管理员账户信息
2. **奖项表 (Awards)**：存储奖项信息，支持等级和数量管理
3. **轮次表 (Epoches)**：支持多轮次抽奖管理
4. **参与者表 (Participants)**：存储人员信息，支持权重和中奖统计
5. **中奖记录表 (Winners)**：存储中奖信息，关联参与者和奖项

**技术特点**：
- 外键约束管理，确保数据完整性
- 默认数据初始化，包含管理员账户和示例数据
- 数据类型优化，使用VARCHAR替代TEXT提高性能
- 统一使用ISO格式的DATETIME

### 1.2 数据库表结构优化
**来源**：项目决策记录01
**问题**：存在重复表结构，命名不统一

**解决方案**：
- 删除重复表，统一表名规范
- 所有表名改为单数形式且首字母大写
- 优化表结构，合并相关字段

**最终表结构**：
- **Admin**：管理员表
- **Award**：奖项表  
- **Epoch**：轮次表
- **Participant**：参与者表
- **Winner**：中奖记录表

### 1.3 奖项等级字段数据格式修正
**来源**：项目决策记录13
**问题**：奖项等级字段存储格式不一致，影响排序和显示

**解决方案**：
- 统一奖项等级字段格式为数字类型
- 修正数据库中的历史数据
- 确保前后端数据类型一致性

**技术实现**：
```sql
-- 修正奖项等级数据格式
UPDATE Award SET level = CAST(level AS INTEGER) WHERE level IS NOT NULL;
```

---

## 二、数据初始化策略

### 2.1 参与者数据导入覆盖功能
**来源**：项目决策记录09
**需求**：导入参与者数据时能够覆盖原有数据，而不是仅添加新数据

**问题分析**：
- 原有导入逻辑只检查是否存在，不存在才插入
- 无法实现数据覆盖更新的需求

**解决方案**：
1. **启用参与者数据导入功能**：取消被注释的导入代码
2. **实现覆盖逻辑**：
   - 插入前先执行 `DELETE FROM "Participant"` 清空现有数据
   - 直接插入所有默认参与者数据，不再检查是否已存在

**技术实现**：
```javascript
// 覆盖模式实现
const defaultParticipants = [...];
// 清空现有参与者数据
await dbRun('DELETE FROM "Participant"');
// 插入新的参与者数据
for (const name of defaultParticipants) {
  await dbRun(...);
}
```

### 2.2 数据库初始化智能检测
**来源**：项目决策记录10
**需求**：系统应智能检测数据库状态，只在没有数据时才插入默认数据

**问题分析**：
- 覆盖模式会无条件清空并重新插入数据
- 需要更智能的检测机制

**解决方案**：
1. **添加数据检测逻辑**：插入前查询数据库中的参与者数量
2. **条件性插入**：只有当参与者数量为0时，才执行默认数据插入
3. **用户友好的日志**：添加不同情况下的控制台输出信息

**技术实现**：
```javascript
// 智能检测实现
const participantCount = await dbGet('SELECT COUNT(*) as count FROM "Participant"');
if (participantCount.count === 0) {
  console.log('数据库为空，插入默认参与者数据...');
  // 执行插入逻辑
} else {
  console.log(`数据库中已有 ${participantCount.count} 个参与者，跳过默认数据插入`);
}
```

### 2.3 数据库初始化数据存在性检测优化
**来源**：项目决策记录12
**需求**：进一步优化数据存在性检测逻辑，提高系统启动效率

**优化内容**：
1. **批量检测**：一次性检测所有表的数据状态
2. **缓存机制**：避免重复查询相同的表
3. **错误处理**：增强数据库连接异常的处理能力

---

## 三、数据管理与约束

### 3.1 重置抽奖数据功能实现与外键约束问题修复
**来源**：项目决策记录27
**需求**：实现完整的数据重置功能，清空所有抽奖相关数据

**问题分析**：
- 外键约束导致删除操作失败
- 需要按照正确的顺序删除数据

**解决方案**：
1. **外键约束处理**：
   - 临时禁用外键约束
   - 按照依赖关系顺序删除数据
   - 重新启用外键约束

2. **删除顺序**：
   ```sql
   -- 正确的删除顺序
   DELETE FROM Winner;      -- 先删除中奖记录
   DELETE FROM Epoch;       -- 再删除轮次数据
   UPDATE Participant SET has_won = 0, win_count = 0; -- 重置参与者状态
   ```

3. **数据完整性验证**：
   - 删除后验证数据状态
   - 确保所有相关数据都已正确重置

### 3.2 参与者表中奖信息同步更新
**来源**：项目决策记录22
**需求**：确保参与者表中的中奖信息与中奖记录表保持同步

**技术实现**：
1. **触发器机制**：创建数据库触发器自动更新参与者状态
2. **应用层同步**：在抽奖逻辑中同时更新两个表
3. **数据一致性检查**：定期验证数据同步状态

---

## 四、系统测试与数据库事务优化

### 4.1 系统测试脚本创建
**来源**：项目决策记录34
**需求**：创建完整的系统测试脚本，验证数据库操作的正确性

**测试覆盖范围**：
1. **数据库连接测试**：验证数据库连接的稳定性
2. **CRUD操作测试**：测试所有表的增删改查操作
3. **外键约束测试**：验证数据完整性约束
4. **并发操作测试**：测试多用户同时操作的情况

### 4.2 数据库事务优化
**来源**：项目决策记录34
**优化内容**：
1. **事务边界优化**：合理划分事务范围
2. **锁机制优化**：减少锁冲突，提高并发性能
3. **错误回滚机制**：确保数据操作的原子性

**技术实现**：
```javascript
// 事务优化示例
const transaction = await db.beginTransaction();
try {
  // 执行多个相关操作
  await transaction.run('INSERT INTO Winner ...');
  await transaction.run('UPDATE Participant ...');
  await transaction.commit();
} catch (error) {
  await transaction.rollback();
  throw error;
}
```

---

## 五、技术演进总结

### 5.1 架构演进历程
1. **初期**：简单的单表结构，功能有限
2. **重构期**：多表关联设计，支持复杂业务逻辑
3. **优化期**：性能优化，数据一致性保障
4. **成熟期**：完善的测试体系，稳定的事务处理

### 5.2 关键技术决策
1. **数据库选择**：SQLite，轻量级且功能完整
2. **表结构设计**：规范化设计，避免数据冗余
3. **约束策略**：外键约束保证数据完整性
4. **初始化策略**：智能检测，避免重复操作

### 5.3 最佳实践总结
1. **数据建模**：充分分析业务需求，设计合理的表结构
2. **约束设计**：合理使用外键约束，平衡性能与完整性
3. **初始化策略**：智能检测现有数据，避免不必要的操作
4. **事务管理**：合理划分事务边界，确保数据一致性
5. **测试覆盖**：建立完整的测试体系，保障系统稳定性

---

## 六、未来优化方向

### 6.1 性能优化
1. **索引优化**：为常用查询字段添加索引
2. **查询优化**：优化复杂查询的执行计划
3. **连接池**：实现数据库连接池，提高并发性能

### 6.2 功能扩展
1. **数据备份**：实现自动数据备份机制
2. **数据迁移**：支持数据库版本升级和迁移
3. **监控告警**：添加数据库性能监控和异常告警

### 6.3 安全加固
1. **访问控制**：细化数据库访问权限
2. **数据加密**：敏感数据加密存储
3. **审计日志**：记录所有数据库操作日志