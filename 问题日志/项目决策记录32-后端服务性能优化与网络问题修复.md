# 项目决策记录32-后端服务性能优化与网络问题修复

## 问题描述

用户反馈后端服务存在以下问题：
1. **启动时间长**：服务启动需要较长时间才能响应请求
2. **抽奖停止偶尔出现网络问题**：抽奖过程中偶尔出现网络超时或连接失败

## 问题分析

### 1. 启动时间长的原因

通过分析后端代码，发现以下性能瓶颈：

**数据库初始化过程复杂**：
- 每次启动都要检查4个表的数据存在性（Admin、Epoch、Award、Participant）
- 每个表都需要执行 `SELECT COUNT(*) as count FROM table` 查询
- 如果表为空，还需要插入默认数据，涉及多次INSERT操作
- 参与者表默认插入20条记录，每条记录一个INSERT语句

**数据库操作未优化**：
```javascript
// 当前实现：每个参与者单独插入
for (const name of defaultParticipants) {
  await dbRun(
    'INSERT INTO "Participant" ("name", "user_id", "department", "weight", "has_won", "win_count", "high_award_level", "createdAt", "updatedAt") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
    [name, null, '技术部', 1.0, 0, 0, 100, currentTime, currentTime]
  );
}
```

### 2. 网络问题的原因

**抽奖逻辑复杂度高**：
- `filterEligibleParticipants` 函数对每个参与者都要执行多次数据库查询
- 每个参与者需要查询中奖历史、当前轮次中奖情况、同奖项中奖情况
- 参与者数量多时，查询次数呈指数级增长

**数据库查询未优化**：
```javascript
// 当前实现：每个参与者单独查询
for (const participant of lotteryPool) {
  // 查询1：获取中奖历史
  const winHistory = await dbAll(`
    SELECT w.*, a.level as award_level
    FROM Winner w
    JOIN Award a ON w.award_id = a.id
    WHERE w.participant_id = ?
  `, [participant.id]);
  
  // 查询2：检查当前轮次中奖
  const currentRoundWin = await dbGet(`
    SELECT COUNT(*) as count FROM Winner 
    WHERE participant_id = ? AND epoch = ?
  `, [participant.id, currentEpoch]);
  
  // 查询3：检查同奖项中奖
  const sameAwardWin = await dbGet(`
    SELECT COUNT(*) as count FROM Winner 
    WHERE participant_id = ? AND award_id = ?
  `, [participant.id, award.id]);
}
```

## 解决方案

### 1. 优化数据库初始化

**批量插入优化**：
```javascript
// 优化后：使用批量插入
if (existingParticipantCount.count === 0) {
  const defaultParticipants = [
    '张雨晨', '李思成', '王梓萱', '陈宇航', '刘欣怡',
    '黄子豪', '周美玲', '吴承翰', '赵雅婷', '孙浩然',
    '徐子涵', '郭雨菲', '何俊杰', '马思琪', '朱天宇',
    '杨雨欣', '林子轩', '范思涵', '金子轩', '唐嘉怡'
  ];

  // 构建批量插入SQL
  const placeholders = defaultParticipants.map(() => '(?, ?, ?, ?, ?, ?, ?, ?, ?)').join(', ');
  const values = [];
  
  for (const name of defaultParticipants) {
    values.push(name, null, '技术部', 1.0, 0, 0, 100, currentTime, currentTime);
  }
  
  await dbRun(
    `INSERT INTO "Participant" ("name", "user_id", "department", "weight", "has_won", "win_count", "high_award_level", "createdAt", "updatedAt") VALUES ${placeholders}`,
    values
  );
  
  console.log('默认参与者数据批量插入完成');
}
```

**数据存在性检查优化**：
```javascript
// 优化后：一次查询检查所有表
const tableChecks = await dbAll(`
  SELECT 
    'Admin' as table_name, COUNT(*) as count FROM Admin
  UNION ALL
  SELECT 
    'Epoch' as table_name, COUNT(*) as count FROM Epoch
  UNION ALL
  SELECT 
    'Award' as table_name, COUNT(*) as count FROM Award
  UNION ALL
  SELECT 
    'Participant' as table_name, COUNT(*) as count FROM Participant
`);

const tableCounts = {};
tableChecks.forEach(check => {
  tableCounts[check.table_name] = check.count;
});
```

### 2. 优化抽奖逻辑

**合并数据库查询**：
```javascript
// 优化后：一次查询获取所有参与者的完整信息
async function filterEligibleParticipants(lotteryPool, award, currentEpoch) {
  if (lotteryPool.length === 0) return [];
  
  const participantIds = lotteryPool.map(p => p.id);
  const placeholders = participantIds.map(() => '?').join(',');
  
  // 一次查询获取所有参与者的中奖信息
  const participantWinInfo = await dbAll(`
    SELECT 
      p.id,
      p.name,
      p.department,
      p.weight,
      COUNT(w.id) as win_count,
      MIN(a.level) as highest_award_level,
      SUM(CASE WHEN w.epoch = ? THEN 1 ELSE 0 END) as current_round_wins,
      SUM(CASE WHEN w.award_id = ? THEN 1 ELSE 0 END) as same_award_wins
    FROM Participant p
    LEFT JOIN Winner w ON p.id = w.participant_id
    LEFT JOIN Award a ON w.award_id = a.id
    WHERE p.id IN (${placeholders})
    GROUP BY p.id, p.name, p.department, p.weight
  `, [currentEpoch, award.id, ...participantIds]);
  
  // 在内存中筛选符合条件的参与者
  const eligible = participantWinInfo.filter(participant => {
    const winCount = participant.win_count || 0;
    const highestAwardLevel = participant.highest_award_level || 999;
    const currentRoundWins = participant.current_round_wins || 0;
    const sameAwardWins = participant.same_award_wins || 0;
    
    // 应用筛选规则
    if (winCount >= 3) return false;
    if (highestAwardLevel <= 2 && award.level <= 2) return false;
    if (currentRoundWins > 0) return false;
    if (sameAwardWins > 0) return false;
    
    return true;
  });
  
  return eligible;
}
```

### 3. 添加数据库连接池

**配置连接池**：
```javascript
// 在 database/init.js 中添加连接池配置
import sqlite3 from 'sqlite3';
import { promisify } from 'util';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '../../data/lottery.db');

// 配置数据库连接选项
const dbOptions = {
  mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
  verbose: console.log // 开发环境下启用详细日志
};

// 创建数据库连接
export const db = new sqlite3.Database(dbPath, dbOptions);

// 优化数据库性能
db.serialize(() => {
  db.run('PRAGMA journal_mode = WAL'); // 启用WAL模式提升并发性能
  db.run('PRAGMA synchronous = NORMAL'); // 平衡性能和数据安全
  db.run('PRAGMA cache_size = 10000'); // 增加缓存大小
  db.run('PRAGMA temp_store = MEMORY'); // 临时数据存储在内存中
});
```

### 4. 添加请求超时和重试机制

**前端API配置优化**：
```javascript
// 在 frontend/src/api/index.js 中添加超时和重试配置
import axios from 'axios'
import { ElMessage } from 'element-plus'

const api = axios.create({
  baseURL: 'http://localhost:8080/api',
  timeout: 30000, // 增加超时时间到30秒
  headers: {
    'Content-Type': 'application/json'
  }
})

// 添加请求重试机制
api.interceptors.response.use(
  response => {
    return response.data
  },
  async error => {
    const config = error.config;
    
    // 如果是网络错误且未达到重试上限，进行重试
    if (!config.__retryCount) {
      config.__retryCount = 0;
    }
    
    if (config.__retryCount < 2 && 
        (error.code === 'ECONNABORTED' || error.message.includes('timeout'))) {
      config.__retryCount += 1;
      
      // 延迟重试
      await new Promise(resolve => setTimeout(resolve, 1000 * config.__retryCount));
      
      return api(config);
    }
    
    // 显示错误信息
    if (error.response) {
      const message = error.response.data?.error || '请求失败'
      ElMessage.error(message)
    } else if (error.request) {
      ElMessage.error('网络连接失败，请检查网络状态')
    } else {
      ElMessage.error('请求配置错误')
    }
    
    return Promise.reject(error)
  }
)
```

### 5. 添加性能监控

**后端性能日志**：
```javascript
// 在 app.js 中添加性能监控中间件
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    if (duration > 1000) { // 记录超过1秒的慢请求
      console.warn(`慢请求警告: ${req.method} ${req.url} - ${duration}ms`);
    }
  });
  
  next();
});
```

## 实施计划

### 第一阶段：数据库优化
1. 优化数据库初始化逻辑
2. 添加数据库性能配置
3. 实施批量插入优化

### 第二阶段：查询优化
1. 重构抽奖逻辑中的数据库查询
2. 合并多次查询为单次查询
3. 添加查询结果缓存

### 第三阶段：网络优化
1. 增加请求超时时间
2. 实施请求重试机制
3. 添加性能监控

## 预期效果

### 启动时间优化
- **优化前**：5-10秒启动时间
- **优化后**：2-3秒启动时间
- **提升幅度**：50-70%

### 抽奖性能优化
- **优化前**：100个参与者需要300+次数据库查询
- **优化后**：100个参与者需要1-2次数据库查询
- **提升幅度**：99%查询次数减少

### 网络稳定性提升
- 添加自动重试机制，减少偶发网络问题
- 增加超时时间，适应复杂抽奖逻辑
- 性能监控帮助及时发现问题

## 风险评估

### 低风险
- 数据库配置优化不影响现有功能
- 批量插入逻辑向后兼容
- 前端重试机制不影响正常请求

### 中等风险
- 抽奖逻辑重构需要充分测试
- 数据库查询合并可能影响数据准确性

### 缓解措施
- 保留原有逻辑作为备份
- 充分的单元测试和集成测试
- 分阶段实施，逐步验证效果

## 测试验证

### 性能测试
1. 测试服务启动时间
2. 测试不同参与者数量下的抽奖性能
3. 测试并发请求处理能力

### 功能测试
1. 验证抽奖逻辑正确性
2. 验证数据一致性
3. 验证错误处理机制

### 压力测试
1. 模拟高并发抽奖场景
2. 测试网络异常恢复能力
3. 验证系统稳定性

---

**创建时间**：2024年12月19日  
**问题类型**：性能优化  
**优先级**：高  
**状态**：分析完成，待实施  
**影响范围**：后端服务性能、前端用户体验