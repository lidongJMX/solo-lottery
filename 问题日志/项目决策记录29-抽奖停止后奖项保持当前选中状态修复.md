# 项目决策记录29-抽奖停止后奖项保持当前选中状态修复

## 问题描述
停止抽奖后，页面会显示中奖者，但同时奖项会直接跳到了一等奖，这是不符合逻辑的。如果进行的是三等奖的抽奖，那么停止抽奖后就应该停留在三等奖而不是跳到其他奖项去。

## 问题分析
1. **问题根源**：在 `drawWinners` 函数中，调用 `await fetchAwards()` 来更新奖项剩余数量时，`fetchAwards` 函数会重置 `currentAward.value = awards.value[0]`，导致页面切换到第一个奖项（一等奖）
2. **触发时机**：每次抽奖完成后，系统需要更新奖项的剩余数量，这时就会触发奖项跳转
3. **影响范围**：用户在非一等奖的奖项上进行抽奖后，抽奖停止时页面会自动切换到一等奖，造成用户困惑

## 解决方案

### 修改内容
采用更精确的解决方案：在 `drawWinners` 函数中保存和恢复当前选中的奖项状态，而不是修改 `fetchAwards` 函数的通用逻辑。

1. **优化 `drawWinners` 函数**：
   - 在调用 `fetchAwards` 前保存当前选中的奖项索引和ID
   - 在 `fetchAwards` 完成后恢复之前选中的奖项
   - 提供双重保障：通过索引和ID来恢复奖项选择

### 具体修改

#### 文件：`frontend/src/components/LotteryPage.vue`

**修改前**：
```javascript
// drawWinners 函数中
// 重新获取奖项数据以更新剩余数量
await fetchAwards();
```

**修改后**：
```javascript
// drawWinners 函数中
// 保存当前选中的奖项索引
const savedIndex = currentIndex.value;
const savedAwardId = currentAward.value.id;

// 重新获取奖项数据以更新剩余数量
await fetchAwards();

// 恢复之前选中的奖项
if (savedIndex >= 0 && savedIndex < awards.value.length) {
  currentIndex.value = savedIndex;
  currentAward.value = awards.value[savedIndex];
  drawCount.value = currentAward.value?.draw_count || 1;
} else {
  // 如果索引无效，尝试通过ID找到对应的奖项
  const foundIndex = awards.value.findIndex(award => award.id === savedAwardId);
  if (foundIndex !== -1) {
    currentIndex.value = foundIndex;
    currentAward.value = awards.value[foundIndex];
    drawCount.value = currentAward.value?.draw_count || 1;
  }
}
```

## 技术优势
1. **精确定位**：只在需要的地方进行修复，不影响其他功能
2. **双重保障**：通过索引和ID两种方式来恢复奖项选择，提高容错性
3. **保持原有逻辑**：不修改 `fetchAwards` 函数的通用逻辑，避免影响其他调用场景
4. **数据同步**：确保 `currentIndex`、`currentAward` 和 `drawCount` 三者保持同步

## 预期效果
1. **保持奖项连续性**：用户在某个奖项上进行抽奖后，抽奖停止时页面不会自动切换到其他奖项
2. **信息一致性**：显示的奖项信息与用户选择的奖项保持一致
3. **更好的用户体验**：用户可以连续在同一奖项上进行多次抽奖，无需重新选择
4. **容错处理**：即使奖项数据结构发生变化，也能通过ID找到正确的奖项

## 测试建议
1. 选择非一等奖的奖项（如三等奖）进行抽奖
2. 开始抽奖并等待抽奖停止
3. 查看抽奖停止后页面显示的奖项是否仍为三等奖
4. 验证中奖弹窗显示的奖项信息是否正确
5. 测试多轮抽奖的连续性
6. 验证奖项切换功能仍然正常工作
7. 测试奖项剩余数量是否正确更新

## 风险评估
- **低风险**：修改仅涉及特定函数的局部逻辑，不影响核心抽奖逻辑
- **向后兼容**：保持了原有的功能，只是优化了用户体验
- **边界情况处理**：添加了索引和ID的双重检查，提高了代码健壮性
- **数据一致性**：确保了界面状态与数据的同步

## 与之前方案的区别
- **更精确**：只在问题发生的具体位置进行修复，而不是修改通用函数
- **更安全**：不影响 `fetchAwards` 函数的其他调用场景
- **更可靠**：提供了索引和ID的双重恢复机制

---

**修复时间**：2024年12月
**影响模块**：前端抽奖页面
**修复类型**：用户体验优化
**关联文件**：frontend/src/components/LotteryPage.vue