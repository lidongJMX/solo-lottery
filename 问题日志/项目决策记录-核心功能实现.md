# 项目决策记录 - 核心功能实现

## 概述
本文档整合了Solo Lottery项目中所有与核心功能实现、抽奖逻辑、数据处理、业务流程相关的项目决策记录，涵盖了从基础抽奖功能到高级管理功能的完整业务实现过程。

---

## 一、抽奖核心逻辑实现

### 1.1 抽奖页面奖项切换功能完善
**来源**：项目决策记录11
**需求**：实现抽奖页面中奖项的动态切换功能

**功能特点**：
1. **动态奖项列表**：从后端获取所有可用奖项
2. **状态同步**：切换奖项时同步更新相关状态
3. **数据验证**：确保选中奖项的有效性
4. **用户反馈**：提供清晰的切换状态指示

**技术实现**：
```javascript
// 奖项切换逻辑
const switchAward = async (awardId) => {
  try {
    // 验证奖项是否存在
    const award = awards.value.find(a => a.id === awardId);
    if (!award) {
      throw new Error('奖项不存在');
    }
    
    // 更新当前奖项
    currentAward.value = award;
    
    // 重置抽奖状态
    isDrawing.value = false;
    currentWinners.value = [];
    
    // 更新UI状态
    updateDrawingInterface();
    
  } catch (error) {
    console.error('切换奖项失败:', error);
    showErrorMessage('切换奖项失败，请重试');
  }
};
```

### 1.2 抽取数量修改功能修复
**来源**：项目决策记录15
**问题**：抽取数量修改后，抽奖逻辑未正确应用新的数量设置

**解决方案**：
1. **实时验证**：修改数量时立即验证有效性
2. **状态同步**：确保前后端数量设置一致
3. **边界检查**：防止超出可用参与者数量
4. **用户提示**：提供清晰的数量限制说明

**技术实现**：
```javascript
// 抽取数量修改逻辑
const updateDrawCount = async (newCount) => {
  try {
    // 验证数量有效性
    if (newCount < 1) {
      throw new Error('抽取数量不能小于1');
    }
    
    // 检查可用参与者数量
    const availableCount = await getAvailableParticipantCount();
    if (newCount > availableCount) {
      throw new Error(`抽取数量不能超过可用参与者数量(${availableCount})`);
    }
    
    // 更新抽取数量
    currentAward.value.quantity = newCount;
    
    // 同步到后端
    await updateAwardQuantity(currentAward.value.id, newCount);
    
    showSuccessMessage('抽取数量更新成功');
    
  } catch (error) {
    console.error('更新抽取数量失败:', error);
    showErrorMessage(error.message);
  }
};
```

### 1.3 轮次获取逻辑修复
**来源**：项目决策记录21
**问题**：轮次信息获取不准确，影响抽奖结果的正确性

**解决方案**：
1. **轮次管理优化**：建立清晰的轮次生命周期管理
2. **状态同步**：确保前后端轮次状态一致
3. **错误处理**：完善轮次获取的异常处理
4. **数据一致性**：保证轮次数据的完整性

**技术实现**：
```javascript
// 轮次获取逻辑
const getCurrentEpoch = async () => {
  try {
    // 从后端获取当前轮次
    const response = await lotteryAPI.getCurrentEpoch();
    
    if (!response.data) {
      // 如果没有当前轮次，创建新轮次
      const newEpoch = await lotteryAPI.createNewEpoch();
      currentEpoch.value = newEpoch.data.id;
    } else {
      currentEpoch.value = response.data.id;
    }
    
    // 更新轮次相关状态
    await updateEpochRelatedData();
    
  } catch (error) {
    console.error('获取轮次信息失败:', error);
    throw new Error('无法获取轮次信息，请刷新页面重试');
  }
};
```

---

## 二、数据管理与同步

### 2.1 参与者表中奖信息同步更新
**来源**：项目决策记录22
**需求**：确保参与者表中的中奖信息与中奖记录表保持同步

**同步策略**：
1. **实时同步**：抽奖完成后立即更新参与者状态
2. **事务保证**：使用数据库事务确保数据一致性
3. **冲突处理**：处理并发更新可能导致的数据冲突
4. **数据校验**：定期校验数据同步状态

**技术实现**：
```javascript
// 中奖信息同步更新
const syncWinnerInfo = async (winnerId, awardId, epochId) => {
  const transaction = await db.beginTransaction();
  
  try {
    // 插入中奖记录
    await transaction.run(
      'INSERT INTO Winner (participant_id, award_id, epoch_id, created_at) VALUES (?, ?, ?, ?)',
      [winnerId, awardId, epochId, new Date().toISOString()]
    );
    
    // 更新参与者状态
    await transaction.run(
      'UPDATE Participant SET has_won = 1, win_count = win_count + 1 WHERE id = ?',
      [winnerId]
    );
    
    // 提交事务
    await transaction.commit();
    
  } catch (error) {
    // 回滚事务
    await transaction.rollback();
    throw error;
  }
};
```

### 2.2 下一轮按钮显示轮次信息
**来源**：项目决策记录23
**需求**：在"下一轮"按钮上显示即将进入的轮次信息

**功能实现**：
1. **轮次计算**：动态计算下一轮次编号
2. **状态显示**：实时更新按钮文本
3. **条件显示**：根据抽奖状态控制按钮可见性
4. **用户引导**：提供清晰的操作指引

**技术实现**：
```vue
<template>
  <button 
    v-if="canStartNextRound"
    @click="startNextRound"
    class="next-round-btn"
  >
    开始第 {{ nextRoundNumber }} 轮抽奖
  </button>
</template>

<script>
const nextRoundNumber = computed(() => {
  return currentEpoch.value + 1;
});

const canStartNextRound = computed(() => {
  return !isDrawing.value && hasCompletedCurrentRound.value;
});
</script>
```

### 2.3 抽奖停止后奖项切换问题修复
**来源**：项目决策记录24、29
**问题**：抽奖停止后，奖项切换功能异常，无法正确保持当前选中状态

**解决方案**：
1. **状态管理优化**：建立清晰的抽奖状态机
2. **事件处理**：正确处理抽奖停止事件
3. **UI同步**：确保界面状态与数据状态一致
4. **用户体验**：提供平滑的状态转换

**技术实现**：
```javascript
// 抽奖状态管理
const lotteryStateMachine = {
  state: 'idle', // idle, drawing, stopped, completed
  
  transitions: {
    idle: ['drawing'],
    drawing: ['stopped', 'completed'],
    stopped: ['drawing', 'idle'],
    completed: ['idle']
  },
  
  setState(newState) {
    if (this.transitions[this.state].includes(newState)) {
      this.state = newState;
      this.onStateChange(newState);
    } else {
      throw new Error(`Invalid state transition: ${this.state} -> ${newState}`);
    }
  },
  
  onStateChange(state) {
    switch (state) {
      case 'stopped':
        // 保持当前奖项选中状态
        maintainAwardSelection();
        break;
      case 'idle':
        // 重置相关状态
        resetDrawingState();
        break;
    }
  }
};
```

---

## 三、数据导入导出功能

### 3.1 抽奖记录列表分页和排序功能
**来源**：项目决策记录25
**需求**：为抽奖记录列表添加分页和排序功能，提升大数据量下的用户体验

**功能特点**：
1. **分页显示**：支持自定义每页显示数量
2. **多字段排序**：支持按时间、奖项、参与者等字段排序
3. **筛选功能**：支持按奖项、轮次等条件筛选
4. **性能优化**：后端分页，减少数据传输量

**技术实现**：
```javascript
// 分页和排序逻辑
const fetchWinnerRecords = async (page = 1, pageSize = 20, sortBy = 'created_at', sortOrder = 'desc', filters = {}) => {
  try {
    const params = {
      page,
      pageSize,
      sortBy,
      sortOrder,
      ...filters
    };
    
    const response = await lotteryAPI.getWinnerRecords(params);
    
    winnerRecords.value = response.data.records;
    totalRecords.value = response.data.total;
    currentPage.value = page;
    
  } catch (error) {
    console.error('获取中奖记录失败:', error);
    showErrorMessage('获取中奖记录失败，请重试');
  }
};

// 排序处理
const handleSort = (column) => {
  if (sortBy.value === column) {
    sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc';
  } else {
    sortBy.value = column;
    sortOrder.value = 'desc';
  }
  
  fetchWinnerRecords(1, pageSize.value, sortBy.value, sortOrder.value, currentFilters.value);
};
```

### 3.2 导出中奖记录功能完善
**来源**：项目决策记录26
**需求**：完善中奖记录的导出功能，支持多种格式和筛选条件

**功能特点**：
1. **多格式支持**：支持Excel、CSV等格式导出
2. **条件导出**：支持按轮次、奖项等条件导出
3. **数据完整性**：确保导出数据的完整性和准确性
4. **用户体验**：提供导出进度提示

**技术实现**：
```javascript
// 导出功能实现
const exportWinnerRecords = async (format = 'excel', filters = {}) => {
  try {
    // 显示导出进度
    showLoadingMessage('正在准备导出数据...');
    
    // 获取导出数据
    const response = await lotteryAPI.exportWinnerRecords({
      format,
      filters,
      includeHeaders: true
    });
    
    // 创建下载链接
    const blob = new Blob([response.data], {
      type: format === 'excel' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 'text/csv'
    });
    
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `中奖记录_${new Date().toISOString().split('T')[0]}.${format === 'excel' ? 'xlsx' : 'csv'}`;
    
    // 触发下载
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
    
    hideLoadingMessage();
    showSuccessMessage('导出成功');
    
  } catch (error) {
    hideLoadingMessage();
    console.error('导出失败:', error);
    showErrorMessage('导出失败，请重试');
  }
};
```

---

## 四、API接口优化

### 4.1 奖项API字段顺序修正
**来源**：项目决策记录14
**问题**：API返回的奖项字段顺序不一致，影响前端数据处理

**解决方案**：
1. **字段标准化**：统一API返回字段的顺序和命名
2. **数据验证**：添加返回数据的格式验证
3. **向下兼容**：确保API变更不影响现有功能
4. **文档更新**：更新API文档说明

**技术实现**：
```javascript
// 标准化的奖项数据结构
const standardizeAwardData = (rawData) => {
  return {
    id: rawData.id,
    level: parseInt(rawData.level),
    name: rawData.name,
    description: rawData.description || '',
    quantity: parseInt(rawData.quantity),
    image_url: rawData.image_url || '',
    created_at: rawData.created_at,
    updated_at: rawData.updated_at
  };
};

// API响应处理
const getAwards = async () => {
  try {
    const response = await fetch('/api/awards');
    const data = await response.json();
    
    // 标准化数据格式
    return data.map(standardizeAwardData);
    
  } catch (error) {
    console.error('获取奖项数据失败:', error);
    throw error;
  }
};
```

### 4.2 API调用方式修复
**来源**：项目决策记录17
**问题**：部分API调用方式不规范，导致错误处理不当

**解决方案**：
1. **统一调用方式**：建立标准的API调用模式
2. **错误处理**：完善错误处理和用户提示
3. **重试机制**：添加网络异常的重试逻辑
4. **状态管理**：统一管理API调用状态

**技术实现**：
```javascript
// 统一的API调用封装
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json'
    };
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    };
    
    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new APIError(response.status, response.statusText);
      }
      
      return await response.json();
      
    } catch (error) {
      if (error instanceof APIError) {
        throw error;
      }
      
      // 网络错误，尝试重试
      if (options.retry !== false) {
        return this.retryRequest(endpoint, options);
      }
      
      throw new NetworkError('网络连接失败，请检查网络设置');
    }
  }
  
  async retryRequest(endpoint, options, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        return await this.request(endpoint, { ...options, retry: false });
      } catch (error) {
        if (i === maxRetries - 1) {
          throw error;
        }
      }
    }
  }
}
```

---

## 五、业务流程优化

### 5.1 重置抽奖数据功能实现
**来源**：项目决策记录27
**需求**：实现完整的数据重置功能，清空所有抽奖相关数据

**功能设计**：
1. **数据范围**：清空中奖记录、轮次数据，重置参与者状态
2. **安全确认**：多重确认机制，防止误操作
3. **数据备份**：重置前自动备份重要数据
4. **操作日志**：记录重置操作的详细信息

**技术实现**：
```javascript
// 重置抽奖数据
const resetLotteryData = async () => {
  try {
    // 用户确认
    const confirmed = await showConfirmDialog({
      title: '确认重置',
      message: '此操作将清空所有抽奖记录和轮次数据，是否继续？',
      confirmText: '确认重置',
      cancelText: '取消',
      type: 'warning'
    });
    
    if (!confirmed) return;
    
    // 显示进度
    showLoadingMessage('正在重置数据，请稍候...');
    
    // 执行重置操作
    await lotteryAPI.resetAllData();
    
    // 重新加载数据
    await refreshAllData();
    
    hideLoadingMessage();
    showSuccessMessage('数据重置成功');
    
  } catch (error) {
    hideLoadingMessage();
    console.error('重置数据失败:', error);
    showErrorMessage('重置数据失败，请重试');
  }
};

// 后端重置逻辑
const resetAllDataAPI = async () => {
  const transaction = await db.beginTransaction();
  
  try {
    // 按照正确的顺序删除数据
    await transaction.run('DELETE FROM Winner');
    await transaction.run('DELETE FROM Epoch');
    await transaction.run('UPDATE Participant SET has_won = 0, win_count = 0');
    
    // 重置自增ID
    await transaction.run('DELETE FROM sqlite_sequence WHERE name IN ("Winner", "Epoch")');
    
    await transaction.commit();
    
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
};
```

### 5.2 抽奖规则文档优化
**来源**：项目决策记录20
**目标**：重新组织抽奖规则文档，提升可读性和理解性

**优化内容**：
1. **结构重组**：按照抽奖资格、中奖限制、特殊机制、执行流程四个模块组织
2. **语言精简**：去除冗余描述，采用简洁易懂的语言
3. **重点突出**：通过格式化突出关键信息
4. **版本管理**：创建新版本文档，保留历史版本

**文档结构**：
```markdown
# 抽奖规则 v2.0

## 一、抽奖资格
- 所有在职员工均可参与
- 每轮抽奖自动包含所有符合条件的参与者

## 二、中奖限制
- **单轮限制**：每人每轮最多中奖一次
- **总体限制**：每人最多中奖两次
- **返场机制**：中奖一次后，下轮中奖概率降为原来的50%

## 三、特殊机制
- **权重系统**：根据中奖历史动态调整中奖概率
- **公平保障**：确保每个参与者都有公平的中奖机会

## 四、执行流程
1. 系统自动筛选符合条件的参与者
2. 根据权重系统计算中奖概率
3. 随机抽取中奖者
4. 更新参与者状态和权重
```

---

## 六、功能完善与用户体验

### 6.1 中奖名单弹窗功能确认
**来源**：项目决策记录30
**功能验证**：确认中奖名单弹窗功能的完整性和正确性

**已实现功能**：
1. **中奖名单按钮**：位置合适，样式统一
2. **数据获取**：正确获取当前奖项的中奖者信息
3. **弹窗展示**：醒目的弹窗设计，信息展示完整
4. **交互体验**：流畅的操作体验

**功能验证清单**：
- ✅ 按钮点击响应正常
- ✅ 数据获取准确无误
- ✅ 弹窗显示效果良好
- ✅ 关闭操作正常
- ✅ 错误处理完善

---

## 七、核心功能架构总结

### 7.1 抽奖算法设计
**核心原则**：
1. **公平性**：确保每个参与者都有公平的机会
2. **随机性**：使用高质量的随机数生成器
3. **可控性**：支持权重调整和规则定制
4. **可验证性**：抽奖过程可追溯和验证

**算法实现**：
```javascript
// 加权随机抽奖算法
const weightedRandomDraw = (participants, count) => {
  // 计算总权重
  const totalWeight = participants.reduce((sum, p) => sum + p.weight, 0);
  
  const winners = [];
  const availableParticipants = [...participants];
  
  for (let i = 0; i < count && availableParticipants.length > 0; i++) {
    // 生成随机数
    const random = Math.random() * totalWeight;
    
    // 根据权重选择中奖者
    let currentWeight = 0;
    let selectedIndex = -1;
    
    for (let j = 0; j < availableParticipants.length; j++) {
      currentWeight += availableParticipants[j].weight;
      if (random <= currentWeight) {
        selectedIndex = j;
        break;
      }
    }
    
    // 添加中奖者并从可选列表中移除
    if (selectedIndex >= 0) {
      winners.push(availableParticipants[selectedIndex]);
      availableParticipants.splice(selectedIndex, 1);
    }
  }
  
  return winners;
};
```

### 7.2 数据流管理
**数据流向**：
1. **用户操作** → **前端状态更新** → **API调用** → **后端处理** → **数据库更新**
2. **数据库变更** → **后端响应** → **前端状态同步** → **UI更新**

**状态管理策略**：
1. **单一数据源**：确保数据状态的唯一性
2. **响应式更新**：数据变更自动触发UI更新
3. **乐观更新**：提升用户体验的同时保证数据一致性
4. **错误恢复**：操作失败时自动恢复到之前状态

### 7.3 性能优化策略
1. **懒加载**：按需加载数据和组件
2. **缓存机制**：合理缓存频繁访问的数据
3. **分页处理**：大数据量的分页显示
4. **防抖节流**：优化用户操作的响应频率

---

## 八、质量保证与测试

### 8.1 功能测试覆盖
1. **核心功能测试**：抽奖逻辑、数据管理、用户交互
2. **边界条件测试**：极限数据量、异常输入处理
3. **兼容性测试**：不同浏览器和设备的兼容性
4. **性能测试**：大并发量下的系统表现

### 8.2 数据完整性验证
1. **事务一致性**：确保相关数据的同步更新
2. **约束验证**：数据库约束的正确性验证
3. **备份恢复**：数据备份和恢复机制的测试
4. **并发控制**：多用户同时操作的数据一致性

---

## 九、未来发展规划

### 9.1 功能扩展方向
1. **多样化抽奖模式**：支持不同类型的抽奖规则
2. **高级统计分析**：提供详细的抽奖数据分析
3. **自动化流程**：支持定时抽奖和自动化管理
4. **集成能力**：与其他系统的集成接口

### 9.2 技术升级计划
1. **微服务架构**：拆分为独立的微服务
2. **实时通信**：WebSocket实现实时数据推送
3. **AI辅助**：智能化的抽奖策略推荐
4. **区块链技术**：提升抽奖过程的透明度和可信度

### 9.3 用户体验提升
1. **个性化设置**：支持用户自定义抽奖规则
2. **移动端优化**：专门的移动端应用
3. **多语言支持**：国际化功能实现
4. **无障碍访问**：提升系统的可访问性